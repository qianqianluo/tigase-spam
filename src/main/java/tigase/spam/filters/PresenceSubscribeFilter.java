/*
 * Tigase Spam Filter - SPAM filters for Tigase XMPP Server
 * Copyright (C) 2017 Tigase, Inc. (office@tigase.com)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. Look for COPYING file in the top folder.
 * If not, see http://www.gnu.org/licenses/.
 */
package tigase.spam.filters;

import tigase.kernel.beans.Bean;
import tigase.kernel.beans.Initializable;
import tigase.kernel.beans.UnregisterAware;
import tigase.kernel.beans.config.ConfigField;
import tigase.server.Packet;
import tigase.spam.SpamProcessor;
import tigase.xmpp.NoConnectionIdException;
import tigase.xmpp.NotAuthorizedException;
import tigase.xmpp.StanzaType;
import tigase.xmpp.XMPPResourceConnection;
import tigase.xmpp.jid.BareJID;

import java.util.LinkedList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

@Bean(name = PresenceSubscribeFilter.ID, parent = SpamProcessor.class, active = true)
public class PresenceSubscribeFilter
		extends AbstractSpamFilter
		implements Initializable, UnregisterAware {

	private static final Logger log = Logger.getLogger(PresenceSubscribeFilter.class.getCanonicalName());

	protected static final String ID = "presence-subscribe";

	private final ConcurrentHashMap<BareJID, Counter> counters = new ConcurrentHashMap<>();

	private Timer cleanerTimer;

	@ConfigField(desc = "Number of allowed subscription requests per minute", alias = "limit-per-minute")
	private int numberOfAllowedRequestsPerMinute = 5;

	@Override
	public String getId() {
		return ID;
	}

	@Override
	public double getSpamProbability() {
		return 0.5;
	}

	@Override
	public void initialize() {
		cleanerTimer = new Timer(ID + "-cleanup");
		cleanerTimer.schedule(new CleanerTask(), 60 * 1000, 60 * 1000);
	}

	@Override
	public void beforeUnregister() {
		if (cleanerTimer != null) {
			cleanerTimer.cancel();
			cleanerTimer = null;
		}
	}

	@Override
	protected boolean filterPacket(Packet packet, XMPPResourceConnection session) {
		try {
//			if (packet.getType() == StanzaType.subscribe && session.isAuthorized() && packet.getStanzaTo() != null &&
//					session.isUserId(packet.getStanzaTo().getBareJID())) {
//				if (!session.isLocalDomain(packet.getStanzaFrom().getDomain(), false)) {
//					PresenceSubscribeOutgoingFilter.Counter counter = counters.computeIfAbsent(packet.getStanzaFrom().getBareJID(), x -> new PresenceSubscribeOutgoingFilter.Counter());
//					return counter.check(numberOfAllowedRequestsPerMinute);
//				}
//			}
			if (packet.getType() == StanzaType.subscribe) {
				// if packet was send from local domain it means that it was already verified and counted
				if (session != null && session.isAuthorized() && packet.getPacketFrom() != null &&
						!packet.getPacketFrom().equals(session.getConnectionId()) && packet.getStanzaFrom() != null &&
						session.isLocalDomain(packet.getStanzaFrom().getDomain(), false)) {
					return true;
				}

				// if packet is coming from sess-man we can assume that it was generated by server so it is ok
				// and was counted on the senders side
				if (session == null && packet.getPacketFrom() != null && "sess-man".equals(packet.getPacketFrom().getLocalpart())) {
					return true;
				}

				BareJID from = null;
				if (packet.getStanzaFrom() != null) {
					from = packet.getStanzaFrom().getBareJID();
				} else if (session != null) {
					from = session.getBareJID();
				} else {
					return true;
				}
				Counter counter = counters.computeIfAbsent(from, x -> new Counter());
				return counter.check(numberOfAllowedRequestsPerMinute);
			}
		} catch (NoConnectionIdException|NotAuthorizedException ex) {
			// ignore this exception for now
		}
		return true;
	}

	protected void cleanUp() {
		counters.entrySet()
				.stream()
				.filter(e -> e.getValue().cleanUp())
				.forEach(e -> counters.remove(e.getKey(), e.getValue()));
	}

	public static class Counter {

		protected List<Long> timestamps = new LinkedList<>();

		public synchronized boolean check(int limit) {
			timestamps.add(System.currentTimeMillis());
			cleanUp();
			if (timestamps.size() > limit) {
				while (timestamps.size() > limit) {
					timestamps.remove(0);
				}
				return false;
			}
			return true;
		}

		public synchronized boolean cleanUp() {
			while ((!timestamps.isEmpty()) && (System.currentTimeMillis() - timestamps.get(0)) > (60 * 1000)) {
				timestamps.remove(0);
			}
			return timestamps.isEmpty();
		}

	}

	private class CleanerTask
			extends TimerTask {

		@Override
		public void run() {
			try {
				cleanUp();
			} catch (Throwable ex) {
				log.log(Level.WARNING, "Exception during cleanup of suspected SPAM message counter table", ex);
			}
		}
	}

}
